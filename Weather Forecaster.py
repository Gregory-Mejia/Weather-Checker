"""

    Contestant Id: 1758
    Date: 4/12/2025

    Prompt: 
    Build a program which accepts a set of latitude/longitude coordinates
    and uses the National Weather Service API to produce a weather forecast
    for today and tonight. Include metrics for temperature (in both fahrenheit and celsius),
    wind speed, wind direction, the likelihood of precipitation, and a brief description
    of the overall weather.

"""

# Importing the standard os library for its console clearing function
from os import system

# Get the request library to make a call to the weather API
# Also import the exceptions to handle errors
from requests import get
from requests import exceptions

# Import the pyplot library from the matplotlib package to plot the temp data
import matplotlib.pyplot as plt

# For the graphing of the temperatures
temp_hours = [] # Each element generated by interpret_weather_data

# Makes a request to an API
def make_request(url: str) -> dict[str]:
    """
        This is a helper function that makes sending and getting requests easier.
        Makes sure there aren't any errors in the request before returning it.
    """

    # Use the requests library to send a request to the given API.
    # Wrap this in an exception to catch upredictable behavior
    try:
        # Make the request using the given url
        request = get(url)
        # Raise an exception if there are any to prevent errors
        request.raise_for_status()
        return request.json() # Return as json to access as a dictionary
    except exceptions.HTTPError as http_error:
        # Catch any HTTP error codes
        print(f"HTTPError: {http_error}\nStatus Code: {request.status_code}")
    except exceptions.Timeout as time_error:
        # Catch if the request times out from taking too long
        print(f"HTTPError: {time_error}")
    except exceptions.RequestException as request_error:
        # Catch if it just errors in general
        print(f"Request Error: {request_error}")

    # Return nothing since an exception would have been raised.
    # The request would have been handled already otherwise.
    return None

# Conversion formula functions
# Convert fahrenheit to celcius
def cel_to_fah(fahrenheit: float) -> float:
    """
        Converts celcius to fahrenheit through its conversion formula.
        Rounds to two decimal places.
    """

    # Formula is (9 / 5) * F + 32
    return round(((9 * fahrenheit) / 5) + 32, 2)

# Convert celcius to fahrenheit
def fah_to_cel(celcius: float) -> float:
    """
        Converts fahrenheit to celcius through its conversion formula.
        Rounds to two decimal places.
    """

    # The formula for conversion is (5 * (C - 32)) / 9
    return round((celcius - 32) * (5 / 9), 2)

# FIlters the data to what is needed by the prompt
def interpret_weather_data(period_data: dict, key: int) -> dict[int]:
    """ 
        Get data for temperature, wind speed, wind direction, precipitation chance,
        and weather description. Return it all in a dictionary.
    """

    # Get the actual data from the key provided 
    data: dict[str] = period_data[key]
    
    # Now, get the wind information
    # 'dir' is short for direction here.
    wind_information = {"speed": data["windSpeed"], "dir": data["windDirection"]}
    # Precipitation chance and weather description
    precipitation = data["probabilityOfPrecipitation"]["value"]

    # Compatibility with hourly forecast
    description: str = None
    if (data["detailedForecast"]):
        description = data["detailedForecast"]

    # Get the temp unit to determine which conversion formulas need to be used
    temp_type = data["temperatureUnit"]
    # Create a dictionary with placeholder values to store our temperatures
    temperature = {"F": None, "C": None}
    temp_num = data["temperature"]
    
    # Check the temperature type
    if (temp_type == "F"):
        # Convert to celcius
        temperature["F"] = temp_num
        temperature["C"] = fah_to_cel(temp_num)
    elif (temp_type == "C"):
        # Convert to fahrenheit
        temperature["F"] = cel_to_fah(temp_num)
        temperature["C"] = temp_num
    else:
        # Something has happened to the temperature data
        print("Temperature error!")

    # Now return all of it in a dictionary
    return {
        "name": data["name"],
        "description": description,
        "temperature": temperature,
        "wind_information": wind_information,
        "precipitation": precipitation
    }

# Translate the coordinates provided to weather information.
def cords_to_info(latitude: float, longitude: float, detailed: bool = False, day: int = 1) -> dict:
    """
        This function will accept two parameters, latitude and longitude.
        It will also accept optional parameter day, which is a number that is at least 1.
        The detailed parameter will give the hourly forecast as well.
        With these, it will get a weather forecast for today and tonight for that location.
    """

    # Format the string using an fstring to avoid funny business with concatenation
    loc_request: dict = make_request(f'https://api.weather.gov/points/{latitude},{longitude}')

    # Check if the request was successful
    if (loc_request):
        # print("Success!")
        # Access the properties of the location data
        data: dict = loc_request["properties"]
        # Send another request for the actual forecast data
        forecast: dict = make_request(data["forecast"])

        if (forecast): # Check for its success again
            # Once again get the properties of the forecast
            forecast_data: dict = forecast["properties"]
            # Access the period data
            # Access format: Keys: [0, 1] are today, [2, 3] tomorrow, and so on.
            period_data: dict = forecast_data["periods"]

            # Get the information keys
            # Assume that the day value is >= 1
            daytime = (day - 1) * 2
            nighttime = (day * 2) - 1

            # Filter the data to get today's weather
            filter_day_data: dict = interpret_weather_data(period_data, daytime)
            filter_night_data: dict = interpret_weather_data(period_data, nighttime)

            # City data checks
            # Get the relative location of the location
            location = data["relativeLocation"]
            # Access its properties
            loc_properties = location["properties"]
            # Get the city and state
            city: str = loc_properties["city"]
            state: str = loc_properties["state"]

            # Definte outside to avoid conflicts
            hourly_view: list = []
            # Return the detailed view if it is found
            if (detailed):
                hourly_request: dict = make_request(data["forecastHourly"])
                hourly_periods: list[int] = None

                # Verify hourly request
                if (hourly_request):
                    hourly_periods = hourly_request["properties"]["periods"]

                    # Get the 24 hour range of hours for that day
                    # Multiply daytime by 12 since 12 * 2 is 24
                    for index in range(daytime * 12, day * 24, 1):
                        # Add to the list
                        to_append = interpret_weather_data(hourly_periods, index)
                        hourly_view.append(to_append)
                        temp_hours.append(to_append)

            # Return the dictionary with all the important stuff
            return {
                "city": city,
                "state": state,
                "day": filter_day_data,
                "night": filter_night_data,
                "detailed": hourly_view
            }
    
    # Request error, yeah! Return nothing as an indicator.
    print("There was an error getting the data.")
    return None

# Plot graphing function
def graph_temperatures():
    """"
        Graphs all the temperature data on a plot that spans all the hours given.
    """

    # Append to this stuff each iteration of the for loop
    x_values = []
    y_values = []

    # Initate the for loop
    index: int
    for index in range(0, len(temp_hours) - 1, 1):
        # Index is the hour, which is the x axis
        x_values.append(index + 1)
        # Get the temperature value and the fahrenheit temperature
        y_values.append(temp_hours[index]["temperature"]["F"])

    # Set-up before graph stuff
    figure, axises = plt.subplots()

    # Pass in the values generated by the for loop
    axises.plot(x_values, y_values)
    axises.set_xlim(1, 48)

    # Set-up the graph
    axises.set_xlabel("Hours")
    axises.set_ylabel("Temperature (Fahrenheit)")
    
    # Show the graph
    plt.title("Temperature Over 48 Hours")
    plt.show()

# A helper function to help format the day and night information
def day_format_printer_helper(data_table: dict[str]) -> None:
    """
        This function helps make the output more readable and standardized.
        Done by passing in the data from the day or night of a day.
    """

    # Reference the keys outside of the dictionary for readability
    date_name: str = data_table["name"]
    desc: str = data_table["description"]
    temperature: dict = data_table["temperature"]
    precipitation: float | None = data_table["precipitation"]
    wind = data_table["wind_information"]

    # Wind subvalues
    wind_dir = wind["dir"]
    wind_speed = wind["speed"]

    # General data
    # Some of these have if statements because of the hourly forecast
    if (date_name):
        print(date_name) # Just printing that string name.
    if (desc):
        print(f"{date_name} Description:\n\t{desc}")
    print(f"Temperature: {temperature["F"]}°F or {temperature["C"]}°C")

    # Use a ternary on this line to determine if a percentage sign is needed.
    print(f"Chance of Precipitation: {precipitation}{"%" if precipitation else ""}")
    print("Wind Information:") # Don't fstring because it isn't needed.

    # Print out all the wind stuff using tabs
    print(f"\tWind Direction: {wind_dir if wind_dir else "No Wind"}")
    print(f"\tWind Speed: {wind_speed}\n")

# Format the data to a readable string 
def format_output_print(data_table: dict[str]) -> None:
    """"
        Formats the data to be more readable in the console.
        Takes in the complete data set generated.
    """

    # Get the days and nights separate from each other
    day_data: dict = data_table["day"]
    night_data: dict = data_table["night"]
    
    # Separator whitespace - would've used \n if it was before another print.
    # Done to group the day and nights together.
    print("-" * 50)
    day_format_printer_helper(day_data)
    day_format_printer_helper(night_data)

    # Check for detailed view
    det_table = data_table["detailed"]
    det_len = len(det_table)

    # Check if it exists
    if (det_len > 0):
        print("Detailed view of this day:")
        # Take the length of the dictionary for the hour count.
        for index in range(0, det_len):
            print(f"{day_data["name"]}, Hour {index + 1}:")
            day_format_printer_helper(det_table[index])

# Helper function to validate user input
def validate_input(text: str, datatype: type) -> type:
    """
        Validates the datatype of the prompt
    """

    # Exception here to prevent funny behavior from invalid input.
    try:
        inp = input(text)
        # Possible data inputs
        if (datatype == bool):
            # Hacky solution because bool() isn't working like I thought
            if (inp.lower() == "true"):
                return True
            elif (inp.lower() == "false"):
                return False
            else:
                # Raise a value error if it isn't a valid boolean
                raise ValueError
        elif (datatype == float):
            inp = float(inp)
        elif (datatype == int):
            inp = int(inp)
        return inp
    except ValueError:
        # Ensures that the user will put in a valid value
        print(f"That was not an acceptable {datatype}.")
        validate_input(text, datatype) # Recursive callback

# Check if this file is being run as the main file
# With the system('cls), we're assuming the user is on windows to clear the output.
if (__name__ == "__main__"):
    # Get rid of all the path data junk above the output
    system('cls')
    lat: float = validate_input("Input the latitude: ", float)
    long: float = validate_input("Input the longitude: ", float)
    det_view: bool = validate_input(
        "Would you like a detailed hourly view? (true/false): ",
        bool)
    graph_view: bool = False

    # Determine if det_view is active
    if (det_view):
        graph_view: bool = validate_input(
            "Would you like a 48 hour temperature graph? (true/false): ",
            bool)

    # Clear the console of anything that isn't the program
    system('cls')

    # Stuff for dealing with if the location name has been printed already.
    outputted_name: bool = False

    # Calculate today's and the next two days' weather in this loop.
    day_pair: int
    # Recall that the input day has to be at least 1, which is today.
    for day_pair in range(1, 3, 1):
        # Calculate the information on the fly.
        information = cords_to_info(lat, long, detailed=det_view, day=day_pair)

        # Start outputting the data to be readable to the human eye
        if (not outputted_name): # Deal with printing the location name once.
            outputted_name = True # Debouce stops this portion from being run.
            if (information):
                print(f'Location: {information["city"]}, {information["state"]}')

        # Format the data received from the HTTP request
        format_output_print(information)
    
    # Create a graph if a graph is found
    if (graph_view):
        graph_temperatures()
